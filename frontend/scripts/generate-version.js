const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

function run(command, cwd) {
  return execSync(command, {
    cwd,
    stdio: ['ignore', 'pipe', 'pipe'],
    encoding: 'utf8',
  }).trim();
}

function toInt(value, fallback) {
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : fallback;
}

function loadConfig(workspaceRoot) {
  const configPath = path.join(workspaceRoot, 'version.config.json');
  const defaults = {
    major: 0,
    phase: 3,
    baseRef: 'origin/main',
    padPhase: 1,
    padCommit: 1,
    commitOffset: 0,
  };

  if (!fs.existsSync(configPath)) {
    return defaults;
  }

  try {
    const parsed = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    return {
      ...defaults,
      ...parsed,
    };
  } catch {
    return defaults;
  }
}

function resolveRepoRoot(workspaceRoot) {
  try {
    return run('git rev-parse --show-toplevel', workspaceRoot);
  } catch {
    return path.resolve(workspaceRoot, '..');
  }
}

function resolveMergeBase(repoRoot, preferredBaseRef) {
  const candidates = [preferredBaseRef, 'origin/main', 'main'].filter(Boolean);
  for (const candidate of candidates) {
    try {
      const mergeBase = run(`git merge-base HEAD ${candidate}`, repoRoot);
      if (mergeBase) {
        return { mergeBase, baseRef: candidate };
      }
    } catch {
      // Ignore invalid candidate and try the next one.
    }
  }
  return { mergeBase: '', baseRef: '' };
}

function computeCommitCount(repoRoot, mergeBase, commitOffset) {
  if (!mergeBase) {
    return Math.max(0, toInt(commitOffset, 0));
  }
  try {
    const raw = toInt(run(`git rev-list --count ${mergeBase}..HEAD`, repoRoot), 0);
    return Math.max(0, raw + toInt(commitOffset, 0));
  } catch {
    return Math.max(0, toInt(commitOffset, 0));
  }
}

function generateVersionFile(workspaceRoot, payload) {
  const outputDir = path.join(workspaceRoot, 'src', 'app', 'core', 'version');
  const outputPath = path.join(outputDir, 'app-version.generated.ts');
  fs.mkdirSync(outputDir, { recursive: true });

  const content = `// This file is auto-generated by scripts/generate-version.js.
// Do not edit manually.

export interface AppVersionInfo {
  major: number;
  phase: number;
  commit: number;
  formatted: string;
  generatedAt: string;
  mergeBase: string;
  baseRef: string;
}

export const APP_VERSION: AppVersionInfo = ${JSON.stringify(payload, null, 2)} as const;
`;

  fs.writeFileSync(outputPath, content, 'utf8');
  console.log(`Generated ${path.relative(workspaceRoot, outputPath)} -> ${payload.formatted}`);
}

function main() {
  const workspaceRoot = process.cwd();
  const config = loadConfig(workspaceRoot);
  const repoRoot = resolveRepoRoot(workspaceRoot);
  const { mergeBase, baseRef } = resolveMergeBase(repoRoot, config.baseRef);
  const major = Math.max(0, toInt(config.major, 0));
  const phase = Math.max(0, toInt(config.phase, 3));
  const commit = computeCommitCount(repoRoot, mergeBase, config.commitOffset);
  const phaseWidth = Math.max(1, toInt(config.padPhase, 1));
  const commitWidth = Math.max(1, toInt(config.padCommit, 1));
  const formatted = `${major}.${String(phase).padStart(phaseWidth, '0')}.${String(commit).padStart(
    commitWidth,
    '0',
  )}`;

  generateVersionFile(workspaceRoot, {
    major,
    phase,
    commit,
    formatted,
    generatedAt: new Date().toISOString(),
    mergeBase,
    baseRef,
  });
}

main();
